<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用git上传本地代码到github仓库</title>
    <url>/2020/07/09/%E4%BD%BF%E7%94%A8git%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%88%B0github%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p><strong>前提条件：安装git，拥有github账号</strong></p>
<hr>
<h4 id="1-创建一个github仓库"><a href="#1-创建一个github仓库" class="headerlink" title="1.创建一个github仓库"></a>1.创建一个github仓库</h4><p><img src="https://img-blog.csdnimg.cn/20200630211236580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM2NTQzNzM=,size_16,color_FFFFFF,t_70" alt=""></p>
<h6 id="创建完成后查看仓库的地址："><a href="#创建完成后查看仓库的地址：" class="headerlink" title="创建完成后查看仓库的地址："></a>创建完成后查看仓库的地址：</h6><p><img src="https://img-blog.csdnimg.cn/20200630211433843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM2NTQzNzM=,size_16,color_FFFFFF,t_70" alt=""></p>
<h4 id="2-创建本地仓库"><a href="#2-创建本地仓库" class="headerlink" title="2.创建本地仓库"></a>2.创建本地仓库</h4><h6 id="打开要上传的代码文件夹，右键git-bash-here，输入以下代码："><a href="#打开要上传的代码文件夹，右键git-bash-here，输入以下代码：" class="headerlink" title="打开要上传的代码文件夹，右键git bash here，输入以下代码："></a>打开要上传的代码文件夹，右键git bash here，输入以下代码：</h6><p>交给github管理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>查看状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>将此文件夹的文件添加带本地仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>提交到本地仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;first commit&#39;</span><br></pre></td></tr></table></figure>



<h4 id="3-由本地仓库推送到github仓库"><a href="#3-由本地仓库推送到github仓库" class="headerlink" title="3.由本地仓库推送到github仓库"></a>3.由本地仓库推送到github仓库</h4><p>提交到github仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xxxxxx.git</span><br></pre></td></tr></table></figure>

<p><em><a href="https://github.com/xxxxxx.git：为第一步最后创建github仓库的地址" target="_blank" rel="noopener">https://github.com/xxxxxx.git：为第一步最后创建github仓库的地址</a></em></p>
<p>推送到github仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>



<div class="note class_name=warning"><p>注意: github创建仓库时有一个Initialize this repository with a README</p>
<p>如果勾选的话$ git push -u origin master 我们则会出错</p>
<p>使用如下命令解决：$ git pull –rebase origin master</p>
<p>之后再进行$ git push -u origin master 就可以成功了 </p></div>]]></content>
      <categories>
        <category>实用技巧</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Java位运算</title>
    <url>/2020/07/19/Java%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h4 id="1-1-Java支持的位运算符"><a href="#1-1-Java支持的位运算符" class="headerlink" title="1.1 Java支持的位运算符"></a>1.1 Java支持的位运算符</h4><p>&amp;：按位与</p>
<p>|：按位或</p>
<p>~：按位非</p>
<p>^：按位异或</p>
<p>&lt;&lt;：左位移</p>
<p>&gt;&gt;：右位移运算符</p>
<p>&gt;&gt;&gt;：无符号右移运算符</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="1-2-按位与（-amp-）"><a href="#1-2-按位与（-amp-）" class="headerlink" title="1.2  按位与（&amp;）"></a>1.2  按位与（&amp;）</h4><table>
<thead>
<tr>
<th>操作数1</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>操作数2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>按位与</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>规则总结：只有两个操作数对应位同为1时，结果为1，其余全为0. （或者是只要有一个操作数为0，结果就为0）</p>
<h4 id="1-3-按位或（-）"><a href="#1-3-按位或（-）" class="headerlink" title="1.3  按位或（|）"></a>1.3  按位或（|）</h4><table>
<thead>
<tr>
<th>操作数1</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>操作数2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>按位或</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>规则总结：只有两个操作数对应位同为0时，结果为0，其余全为1.（或者是只要有一个操作数为1，结果就为1）。</p>
<h4 id="1-4-按位非（-）"><a href="#1-4-按位非（-）" class="headerlink" title="1.4  按位非（~）"></a>1.4  按位非（~）</h4><table>
<thead>
<tr>
<th>操作数1</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td>按位非</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h4 id="1-3-按位异或（-）"><a href="#1-3-按位异或（-）" class="headerlink" title="1.3  按位异或（^）"></a>1.3  按位异或（^）</h4><table>
<thead>
<tr>
<th>操作数1</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>操作数2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>按位异或</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>规则总结：相同为0，异：1.</p>
<h4 id="1-6-左位移（-lt-lt-）"><a href="#1-6-左位移（-lt-lt-）" class="headerlink" title="1.6 左位移（&lt;&lt;）"></a>1.6 左位移（&lt;&lt;）</h4><p>算术左移（&lt;&lt;）: 符号位不变，低位补0。如：2&lt;&lt;2结果为8。</p>
<p><img src="https://img-blog.csdn.net/20161012133936660?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h4 id="1-7-右位移（-gt-gt-）"><a href="#1-7-右位移（-gt-gt-）" class="headerlink" title="1.7 右位移（&gt;&gt;）"></a>1.7 右位移（&gt;&gt;）</h4><p>低位溢出，符号位不变，并用符号位补溢出的高位。如：-6&gt;&gt;2结果为-2。</p>
<p><img src="https://img-blog.csdn.net/20161012133940950?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 136.只出现一次的数字</title>
    <url>/2020/07/19/LeetCode-136%EF%BC%9A%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="方法：使用位运算"><a href="#方法：使用位运算" class="headerlink" title="方法：使用位运算"></a>方法：使用位运算</h4><p>答案是使用位运算。对于这道题，可使用异或运算 \oplus⊕。异或运算有以下三个性质。</p>
<p>1.任何数和 0 做异或运算，结果仍然是原来的数<br>2.任何数和其自身做异或运算，结果是 0。<br>3.异或运算满足交换律和结合律。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 169.多数元素</title>
    <url>/2020/07/19/LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h4><p>既然数组中有出现次数&gt; ⌊ n/2 ⌋的元素，那排好序之后的数组中，相同元素总是相邻的。<br>即存在长度&gt; ⌊ n/2 ⌋的一长串 由相同元素构成的连续子数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h4><p>候选人(cand_num)初始化为nums[0]，票数count初始化为1。<br>当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。<br>当票数count为0时，更换候选人，并将票数count重置为1。<br>遍历完数组后，cand_num即为最终答案。</p>
<p>为何这行得通呢？<br>投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。<br>且“多数元素”的个数&gt; ⌊ n/2 ⌋，其余元素的个数总和&lt;= ⌊ n/2 ⌋。<br>因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 &gt;= 1。<br>这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cand_num = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cand_num == nums[i])</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">                cand_num = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>摩尔投票</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104.二叉树的最大深度</title>
    <url>/2020/07/20/LeetCode-1104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> left_height = maxDepth(root.left);</span><br><span class="line">      <span class="keyword">int</span> right_height = maxDepth(root.right);</span><br><span class="line">      <span class="keyword">return</span> java.lang.Math.max(left_height, right_height) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>其中 N 是结点的数量。<br>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 \log(N)。因此，在这种情况下的空间复杂度将是 O(\log(N))。</p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// bfs</span></span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">int</span> size = queue.size();</span><br><span class="line">           depth++;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">               TreeNode temp = queue.poll();</span><br><span class="line">               <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.add(temp.left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.add(temp.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(N)。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 21.合并两个有序链表</title>
    <url>/2020/07/20/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(n + m)O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)。</p>
<p>空间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)。</p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p>
<p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode prev = prehead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(n + m)，其中 n和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</p>
<p>空间复杂度：O(1) 。我们只需要常数的空间存放若干变量。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制工具入门</title>
    <url>/2020/07/21/Git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="Git-与其他版本管理系统的主要区别"><a href="#Git-与其他版本管理系统的主要区别" class="headerlink" title="Git 与其他版本管理系统的主要区别"></a>Git 与其他版本管理系统的主要区别</h4><p>​    大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p>
<p>​    Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。</p>
<h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><h5 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h5><p>在现有目录中初始化仓库: 进入项目目录运行命令,该命令将创建一个名为 <code>.git</code> 的子目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p><strong>检测当前文件状态</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p><strong>提出更改（把它们添加到暂存区</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add 文件</span><br></pre></td></tr></table></figure>

<p><strong>提交更新:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure>

<h5 id="对文件重命名-："><a href="#对文件重命名-：" class="headerlink" title="对文件重命名 ："></a><strong>对文件重命名</strong> ：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git mv README.md README</span><br></pre></td></tr></table></figure>

<h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure>

<h5 id="切换到分支-记录"><a href="#切换到分支-记录" class="headerlink" title="切换到分支/记录"></a>切换到分支/记录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 分支名&#x2F;记录名</span><br></pre></td></tr></table></figure>

<h5 id="分支合并两种方法："><a href="#分支合并两种方法：" class="headerlink" title="分支合并两种方法："></a>分支合并两种方法：</h5><h6 id="Merge：该方法合并会创建一个新的节点，该节点继承合并的两个节点的所有记录。"><a href="#Merge：该方法合并会创建一个新的节点，该节点继承合并的两个节点的所有记录。" class="headerlink" title="Merge：该方法合并会创建一个新的节点，该节点继承合并的两个节点的所有记录。"></a>Merge：该方法合并会创建一个新的节点，该节点继承合并的两个节点的所有记录。</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge 待合并分支</span><br></pre></td></tr></table></figure>

<h6 id="rebase：该方法将原分支的记录创建一个副本移到待合并的分支的顶端，是记录树只有一条。"><a href="#rebase：该方法将原分支的记录创建一个副本移到待合并的分支的顶端，是记录树只有一条。" class="headerlink" title="rebase：该方法将原分支的记录创建一个副本移到待合并的分支的顶端，是记录树只有一条。"></a>rebase：该方法将原分支的记录创建一个副本移到待合并的分支的顶端，是记录树只有一条。</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase 待合并分支</span><br></pre></td></tr></table></figure>

<h5 id="相对引用：-相当于往上移动一个记录，-4向上移动4个记录"><a href="#相对引用：-相当于往上移动一个记录，-4向上移动4个记录" class="headerlink" title="相对引用：^相当于往上移动一个记录，~4向上移动4个记录"></a>相对引用：^相当于往上移动一个记录，~4向上移动4个记录</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 分支名^ </span><br><span class="line">git checkout 分支名~3</span><br></pre></td></tr></table></figure>

<h5 id="强制修改分支位置"><a href="#强制修改分支位置" class="headerlink" title="强制修改分支位置"></a>强制修改分支位置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -f 分支名 HEAD~3</span><br></pre></td></tr></table></figure>

<h5 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h5><p>本地撤销</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure>

<p>远程变更</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure>



<h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><h5 id="复制远程仓库"><a href="#复制远程仓库" class="headerlink" title="复制远程仓库"></a>复制远程仓库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone</span><br></pre></td></tr></table></figure>

<h5 id="拉取远程仓库的更新-默认使用merge合并"><a href="#拉取远程仓库的更新-默认使用merge合并" class="headerlink" title="拉取远程仓库的更新:默认使用merge合并"></a>拉取远程仓库的更新:默认使用merge合并</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h5 id="推送更新到远程仓库"><a href="#推送更新到远程仓库" class="headerlink" title="推送更新到远程仓库"></a>推送更新到远程仓库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<h5 id="避免本地仓库与远程仓库不同步，更新时先拉取后推送"><a href="#避免本地仓库与远程仓库不同步，更新时先拉取后推送" class="headerlink" title="避免本地仓库与远程仓库不同步，更新时先拉取后推送"></a>避免本地仓库与远程仓库不同步，更新时先拉取后推送</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull --rebase push</span><br></pre></td></tr></table></figure>



<h4 id="推荐："><a href="#推荐：" class="headerlink" title="推荐："></a>推荐：</h4><p>Learn Git Branching <a href="https://oschina.gitee.io/learn-git-branching/" target="_blank" rel="noopener">https://oschina.gitee.io/learn-git-branching/</a> 。该网站可以方便的演示基本的git操作，讲解得明明白白。每一个基本命令的作用和结果。</p>
]]></content>
      <categories>
        <category>实用技巧</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 64.求1+2+..n</title>
    <url>/2020/07/23/%E5%89%91%E6%8C%87Offer-64-%E6%B1%821-2-n/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="短路-递归"><a href="#短路-递归" class="headerlink" title="短路 递归"></a>短路 递归</h4><h5 id="逻辑运算符的短路效应："><a href="#逻辑运算符的短路效应：" class="headerlink" title="逻辑运算符的短路效应："></a>逻辑运算符的短路效应：</h5><p>常见的逻辑运算符有三种，即 “与 &amp;&amp;&amp;&amp; ”，“或 ||∣∣ ”，“非 !! ” ；而其有重要的短路效应，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(A &amp;&amp; B)  &#x2F;&#x2F; 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</span><br><span class="line"></span><br><span class="line">if(A || B) &#x2F;&#x2F; 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</span><br></pre></td></tr></table></figure>

<p>本题需要实现 “当 n = 1<em>n</em>=1 时终止递归” 的需求，可通过短路效应实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &gt; 1 &amp;&amp; sumNums(n - 1) &#x2F;&#x2F; 当 n &#x3D; 1 时 n &gt; 1 不成立 ，此时 “短路”</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> x = n &gt; <span class="number">1</span> &amp;&amp; sumNums(n - <span class="number">1</span>) &gt; <span class="number">0</span>;</span><br><span class="line">        res += n;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul>
<li><strong>时间复杂度 O(n)：</strong> 计算 n + (n-1) + … +2+1 需要开启 n 个递归函数。</li>
<li><strong>空间复杂度 O(n)：</strong> 递归深度达到 n，系统使用 O(n)大小的额外空间。</li>
</ul>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 11.盛最多水的容器</title>
    <url>/2020/07/23/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="方法：双指针法"><a href="#方法：双指针法" class="headerlink" title="方法：双指针法"></a>方法：双指针法</h4><p>我们先从题目中的示例开始，一步一步地解释双指针算法的过程。稍后再给出算法正确性的证明。</p>
<p>题目中的示例为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 8, 6, 2, 5, 4, 8, 3, 7]</span><br><span class="line"> ^                       ^</span><br></pre></td></tr></table></figure>

<p>在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 \min(1, 7) * 8 = 8min(1,7)∗8=8。</p>
<p>此时我们需要移动一个指针。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由</p>
<p>两个指针指向的数字中较小值 * 指针之间的距离两个指针指向的数字中较小值∗指针之间的距离</p>
<p>决定的。如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 <strong>数字较小的那个指针</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> re=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxx=Math.min(height[left],height[right])*(right-left);</span><br><span class="line">            re=Math.max(maxx,re);</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;=height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，双指针总计最多遍历整个数组一次。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1.两数之和</title>
    <url>/2020/07/21/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h4><p>暴力法很简单，遍历每个元素 x<em>x</em>，并查找是否存在一个值与 target - x<em>t<strong>a</strong>r<strong>g</strong>e*<em>t</em>−*x</em> 相等的目标元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li><p>时间复杂度：O(n^2)<br>对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
<h4 id="方法2：使用hashmap"><a href="#方法2：使用hashmap" class="headerlink" title="方法2：使用hashmap"></a>方法2：使用hashmap</h4><ul>
<li>遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 <code>target-nums[i]</code> 的 key 值</li>
<li>如果存在则找到了两个值，如果不存在则将当前的 <code>(nums[i],i)</code> 存入 map 中，继续遍历直到找到为止</li>
<li>如果最终都没有结果则抛出异常</li>
<li>时间复杂度：O(n)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 20.有效的括号</title>
    <url>/2020/07/22/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="使用辅助栈法"><a href="#使用辅助栈法" class="headerlink" title="使用辅助栈法"></a>使用辅助栈法</h4><p>思路是每遇到一个左括号就将相应的右括号入栈，利用栈先进先出的原理，当遇到右括号时，判断栈顶的符号是否一致，一致就出栈。最后栈为空则成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span>)</span><br><span class="line">                stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'&#123;'</span>)</span><br><span class="line">                stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">'['</span>)</span><br><span class="line">                stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.empty()||c!=stack.pop())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>辅助栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 46.全排列</title>
    <url>/2020/07/25/LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="方法：「回溯」算法（深度优先遍历-状态重置-剪枝）"><a href="#方法：「回溯」算法（深度优先遍历-状态重置-剪枝）" class="headerlink" title="方法：「回溯」算法（深度优先遍历 + 状态重置 + 剪枝）"></a>方法：「回溯」算法（深度优先遍历 + 状态重置 + 剪枝）</h4><p>使用编程的方法得到全排列，就是在这样的一个树形结构中进行编程，具体来说，就是<strong>执行一次深度优先遍历，从树的根结点到叶子结点形成的路径就是一个全排列</strong>。</p>
<p><img src="https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png" alt="image.png"></p>
<p>说明：</p>
<p>1、每一个结点表示了“全排列”问题求解的不同阶段，这些阶段通过变量的“不同的值”体现；<br>2、这些变量的不同的值，也称之为“状态”；<br>3、使用深度优先遍历有“回头”的过程，在“回头”以后，状态变量需要设置成为和先前一样；<br>4、因此在回到上一层结点的过程中，需要撤销上一次选择，这个操作也称之为“状态重置”；<br>5、深度优先遍历，可以直接借助系统栈空间，为我们保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，<code>path</code> 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 <code>path</code> 变量是一个栈。<br>6、深度优先遍历通过“回溯”操作，实现了全局使用一份状态变量的效果。</p>
<p>下面我们解释如何编码：</p>
<p>1、首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即在已经选了一些数的前提，我们需要在剩下还没有选择的数中按照顺序依次选择一个数，这显然是一个递归结构；</p>
<p>2、递归的终止条件是，数已经选够了，因此我们需要一个变量来表示当前递归到第几层，我们把这个变量叫做 <code>depth</code>；</p>
<p>3、这些结点实际上表示了搜索（查找）全排列问题的不同阶段，为了区分这些不同阶段，我们就需要一些变量来记录为了得到一个全排列，程序进行到哪一步了，在这里我们需要两个变量：</p>
<p>（1）已经选了哪些数，到叶子结点时候，这些已经选择的数就构成了一个全排列；<br>（2）一个布尔数组 <code>used</code>，初始化的时候都为 <code>false</code> 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 <code>true</code> ，这样在考虑下一个位置的时候，就能够以 O(1)<em>O</em>(1) 的时间复杂度判断这个数是否被选择过，这是一种“以空间换时间”的思想。</p>
<p>我们把这两个变量称之为“状态变量”，它们表示了我们在求解一个问题的时候所处的阶段。</p>
<p>4、在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。</p>
<p>5、另外，因为是执行深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做“状态重置”，即“回到过去”、“恢复现场”，我们举一个例子。</p>
<p>从 <code>[1, 2, 3]</code> 到 <code>[1, 3, 2]</code> ，深度优先遍历是这样做的，从 <code>[1, 2, 3]</code> 回到 <code>[1, 2]</code> 的时候，需要撤销刚刚已经选择的数 <code>3</code>，因为在这一层只有一个数 <code>3</code> 我们已经尝试过了，因此程序回到上一层，需要撤销对 <code>2</code> 的选择，好让后面的程序知道，选择 <code>3</code> 了以后还能够选择 <code>2</code>。</p>
<p>这种在遍历的过程中，从深层结点回到浅层结点的过程中所做的操作就叫“回溯”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 首先是特判</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 使用一个动态数组保存所有可能的全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(nums, len, <span class="number">0</span>, path, used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;Integer&gt; path, <span class="keyword">boolean</span>[] used,</span></span></span><br><span class="line"><span class="function"><span class="params">                     List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                dfs(nums, len, depth + <span class="number">1</span>, path, used, res);</span><br><span class="line">                <span class="comment">// 注意：这里是状态重置，是从深层结点回到浅层结点的过程，代码在形式上和递归之前是对称的</span></span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 53.最大子序和</title>
    <url>/2020/08/01/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h4><p>于是我们把目光落到动态规划上面来，首先需要把这个问题分解成最优子问题来解。最主要的思路就是将上面的45个组合进行分类，分解成数量较少的几个子问题。在这里我们一共有9个数字，顺理成章的我们把组合分解成9个小组的组合。</p>
<p>第一个子组合是以第一个数字结尾的连续序列，也就是[-2]，最大值-2</p>
<p>第二个子组合是以第二个数字结尾的连续序列，也就是[-2,1], [1]，最大值1</p>
<p>第三个子组合是以第三个数字结尾的连续序列，也就是[-2,1,3], [1,3], [3]，最大值4</p>
<p>以此类推。。。</p>
<p>如果我们能够得到每一个子组合的最优解，也就是子序列的最大值，整体的最大值就可以通过比较这9个子组合的最大值来得到了。现在我们找到了最优子问题，重叠子问题在哪呢？那就得细心比较一下每个子问题。</p>
<p>从第二个子组合和第三个子组合可以看到，组合3只是在组合2的基础上每一个数组后面添加第3个数字，也就是3，然后增加一个只有第三个数字的数组[3]。这样两个组合之间的关系就出现了，可是我们不关心这个序列是怎么生成的，只是关心最大值之间的关系。我们将子组合三分成两种情况：</p>
<p>继承子组合二得到的序列，也就是[-2,1,3], [1,3] （最大值 = 第二个组合的最大值 + 第三个数字）<br>单独第三个数字的序列，也就是[3] （最大值 = 第三个数字）<br>如果第二个序列的最大值大于0，那么最大值1就比最大值2要大，反之最大值2较大。这样，我们就通过第二个组合的最大值和第三个数字，就得到了第三个组合的最大值。因为第二个组合的结果被重复用到了，所以符合这个重叠子问题的定义。通俗来讲这个问题就变成了，第i个子组合可以通过第i-1个子组合的最大值和第i个数字获得，如果第i-1个子组合的最大值没法给第i个数字带来正增益，我们就抛弃掉前面的子组合，自己就是最大的了。</p>
<p>\begin{aligned} &amp;如果Max(i-1) &gt; 0, Max(i) = Max(i-1) + Nums(i) \ &amp;如果Max(i-1) &lt;= 0, Max(i) = Nums(i) \end{aligned}</p>
<p>如果Max(i−1)&gt;0,Max(i)=Max(i−1)+Nums(i)<br>如果Max(i−1)&lt;=0,Max(i)=Nums(i)</p>
<p>来看看代码，我们只需要一个变量subMax保存前面子组合的最大值，另外一个max保存全局最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> max = nums[<span class="number">0</span>];    <span class="comment">// 全局最大值</span></span><br><span class="line">       <span class="keyword">int</span> subMax = nums[<span class="number">0</span>];  <span class="comment">// 前一个子组合的最大值</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (subMax &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 前一个子组合最大值大于0，正增益</span></span><br><span class="line">               subMax = subMax + nums[i];</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 前一个子组合最大值小于0，抛弃前面的结果</span></span><br><span class="line">               subMax = nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 计算全局最大值</span></span><br><span class="line">           max = Math.max(max, subMax);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 70.爬楼梯</title>
    <url>/2020/08/01/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h4><p>本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和</p>
<p>爬上 n-1n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶<br>爬上 n-2n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶<br>所以我们得到公式 dp[n] = dp[n-1] + dp[n-2]dp[n]=dp[n−1]+dp[n−2]<br>同时需要初始化 dp[0]=1dp[0]=1 和 dp[1]=1dp[1]=1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(\log n)<em>O</em>(log<em>n</em>)，<code>pow</code> 方法将会用去 O(\log n)<em>O</em>(log<em>n</em>) 的时间。</li>
<li>空间复杂度：O(1)<em>O</em>(1)。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 64.最小路径和</title>
    <url>/2020/08/02/LeetCode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h4 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h4><h5 id="状态定义："><a href="#状态定义：" class="headerlink" title="状态定义："></a>状态定义：</h5><p>设 dp 为大小 m×n 矩阵，其中 dp[i][j]的值代表直到走到 (i,j) 的最小路径和。</p>
<p>题目要求，只能向右或向下走，换句话说，当前单元格(i,j) 只能从左方单元格 (i-1,j)或上方单元格 (i,j-1) 走到，因此只需要考虑矩阵左边界和上边界。</p>
<p>具体分为以下 4 种情况：</p>
<p><strong>当左边和上边都不是矩阵边界时：</strong></p>
<p><strong>当只有左边是矩阵边界时：</strong></p>
<p><strong>当只有上边是矩阵边界时：</strong></p>
<p><strong>当左边和上边都是矩阵边界时：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)  grid[i][j] = grid[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)  grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] = Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><p>时间复杂度 O(M \times N)O(M×N) ： 遍历整个 gridgrid 矩阵元素。<br>空间复杂度 O(1)O(1) ： 直接修改原矩阵，不使用额外空间。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
